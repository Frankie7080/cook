#include "cook/process/build/Graph.hpp"
#include "gubg/graph/TopologicalSort.hpp"

namespace cook { namespace process { namespace build {

Graph::vertex_descriptor Graph::goc_vertex(const FileLabel & path)
{
    auto it = file_map_.find(path);
    if (it != file_map_.end())
        return it->second;

    auto v = gubg::graph::add_vertex(Label(path), g_);
    file_map_.insert(std::make_pair(path, v));

    return v;
}

Graph::vertex_descriptor Graph::add_vertex(CommandLabel ptr)
{
    return gubg::graph::add_vertex(Label(ptr), g_);
}

Result Graph::add_edge(vertex_descriptor consumer, vertex_descriptor producer, EdgeType type)
{
    MSS_BEGIN(Result);

    const Label & consumer_label = gubg::graph::vertex_label(consumer, g_);
    const Label & producer_label = gubg::graph::vertex_label(producer, g_);

    MSS(consumer_label.index() !=  producer_label.index());

    const FileLabel * lbl = std::get_if<FileLabel>(&producer_label);
    if (!!lbl)
    {
        auto p = gubg::graph::in_edges(producer, g_);
        MSG_MSS(p.empty(), InternalError, "file " << *lbl << " is already generated by another command");
    }

    gubg::graph::add_edge(consumer, producer, type, g_);

    MSS_END();

}

const Graph::Label & Graph::operator[](vertex_descriptor vd) const
{
    return gubg::graph::vertex_label(vd, g_);
}

Result Graph::topological_commands(std::vector<vertex_descriptor> & commands) const
{
    MSS_BEGIN(Result);
    std::vector<vertex_descriptor> top_order(num_vertices());
    L(C(top_order.size()));

    MSG_MSS(construct_topological_order(g_, top_order.rbegin()), InternalError, "The execution graph is not acyclic");

    commands.clear();
    for(vertex_descriptor vd : top_order)
    {
        const Label & l = gubg::graph::vertex_label(vd, g_);
        const CommandLabel * lbl = std::get_if<CommandLabel>(&l);

        if (!!lbl)
            commands.push_back(vd);
    }

    MSS_END();
}

} } }


